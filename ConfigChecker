#!/bin/bash

# Colors & symbols
GREEN="\033[0;32m"
RED="\033[0;31m"
RESET="\033[0m"
HEAVY_TICK="${GREEN}✔${RESET}"
tick='✔'
cross='✗'
bullet="●"
subbullet="└──"

print_separator() {
  printf '=%.0s' $(seq 1 51)
  echo
}

print_header() {
  local title="$1"
  local width=51
  local pad=$(( (width - ${#title}) / 2 ))
  print_separator
  printf "%*s%s%*s\n" $pad "" "$title" $pad ""
  print_separator
}

print_bullet() { printf "%s %s\n" "$bullet" "$1"; }
print_subbullet() { printf "  %s %s %b\n" "$subbullet" "$1" "${2:-}"; }

print_status_line() {
  if [[ "$1" == "Correct" ]]; then
    printf "  %s Status: ${GREEN}Correct Setup %b${RESET}\n" "$subbullet" "$HEAVY_TICK"
  else
    printf "  %s Status: ${RED}Incorrect Setup %b${RESET}\n" "$subbullet" "$cross"
  fi
}

SetupType() {
  local mode="$1"
  if [[ "$mode" == "multi" ]]; then
    printf "  %s Setup Style : Multiple %s\n" "$subbullet" "$tick"
  else
    printf "  %s Setup Style : Single %s\n" "$subbullet" "$tick"
  fi
}

prompt_and_clear_line() {
  local prompt_msg="$1"
  local var_name="$2"
  local capture_msg="$3"

  while true; do
    printf "%s" "$prompt_msg"
    IFS= read -r input_val

    if [[ -n "$input_val" ]]; then
      # Clear prompt line from terminal
      tput cuu 1
      tput el

      # Assign input to variable by name
      printf -v "$var_name" "%s" "$input_val"

      # Print captured input acknowledgement line
      print_subbullet "$capture_msg" "$HEAVY_TICK"

      break
    else
      echo "Value cannot be empty!"
    fi
  done
}

check_prerequisites() {
  print_header "Prerequisites Check"
  print_bullet "Prerequisites (gawk tool)"
  if command -v gawk >/dev/null 2>&1; then
    print_subbullet "Status: Found" "$tick"
    print_subbullet "Installation: Skipped" "$tick"
    AWK_BIN="gawk"
  else
    print_subbullet "Status: Not Found" "$cross"
    if [[ $(id -u) == 0 && $(command -v apt-get) ]]; then
      print_subbullet "Installation: Started" ""
      if apt-get update -qq && apt-get install -y -qq gawk; then
        print_subbullet "Install: Success" "$tick"
        AWK_BIN="gawk"
      else
        print_subbullet "Install: Failed" "$cross"
        AWK_BIN="awk"
      fi
    else
      print_subbullet "Installation: Skipped" "$cross"
      AWK_BIN="awk"
    fi
  fi
  print_separator
  clear
}

check_yml_validator_and_multi() {
  local file="$1"
  if grep -q "PUBLISHER" "$file"; then
    if grep -E '^[[:space:]]*VALIDATOR_PRIVATE_KEYS:[[:space:]]*\$\{VALIDATOR_PRIVATE_KEYS\}[[:space:]]*$' "$file" >/dev/null && \
       grep -E '^[[:space:]]*SEQ_PUBLISHER_PRIVATE_KEY:[[:space:]]*\$\{PUBLISHER_PRIVATE_KEY\}[[:space:]]*$' "$file" >/dev/null; then
      echo "multi"
      return 0
    else
      echo "multi"
      return 1
    fi
  else
    if grep -E '^[[:space:]]*VALIDATOR_PRIVATE_KEYS:[[:space:]]*\$\{VALIDATOR_PRIVATE_KEYS\}[[:space:]]*$' "$file" >/dev/null; then
      echo "single"
      return 0
    else
      echo "single"
      return 1
    fi
  fi
}

check_yml_env_keys() {
  local file="$1"
  local setup="$2"
  missing_keys=()
  local failed=0

  local -a keys=(
    "ETHEREUM_HOSTS:ETHEREUM_RPC_URL"
    "L1_CONSENSUS_HOST_URLS:CONSENSUS_BEACON_URL"
    "VALIDATOR_PRIVATE_KEYS:VALIDATOR_PRIVATE_KEYS"
    "COINBASE:COINBASE"
    "P2P_IP:P2P_IP"
  )

  if [[ "$setup" == "multi" ]]; then
    keys+=("SEQ_PUBLISHER_PRIVATE_KEY:PUBLISHER_PRIVATE_KEY")
  fi

  for pair in "${keys[@]}"; do
    local key="${pair%%:*}"
    local var="${pair#*:}"
    local regex="^[[:space:]]*${key}:[[:space:]]*\\\${${var}}[[:space:]]*$"
    if ! grep -qE "$regex" "$file"; then
      missing_keys+=("$key")
      failed=1
    fi
  done

  if (( failed )); then
    return 1
  fi
  return 0
}

fix_yml_file() {
  local file="$1"
  local multivalid="$2"
  local tmpfile
  tmpfile=$(mktemp)

  if [[ "$multivalid" == "multi" ]]; then
    cat > "$tmpfile" <<EOF
services:
  aztec-node:
    container_name: aztec-sequencer
    image: aztecprotocol/aztec:2.0.2
    restart: unless-stopped
    network_mode: host
    environment:
      ETHEREUM_HOSTS: \${ETHEREUM_RPC_URL}
      L1_CONSENSUS_HOST_URLS: \${CONSENSUS_BEACON_URL}
      DATA_DIRECTORY: /data
      VALIDATOR_PRIVATE_KEYS: \${VALIDATOR_PRIVATE_KEYS}
      SEQ_PUBLISHER_PRIVATE_KEY: \${PUBLISHER_PRIVATE_KEY}
      COINBASE: \${COINBASE}
      P2P_IP: \${P2P_IP}
      LOG_LEVEL: info
    entrypoint: >
      sh -c 'node --no-warnings /usr/src/yarn-project/aztec/dest/bin/index.js start --network testnet --node --archiver --sequencer'
    ports:
      - 40400:40400/tcp
      - 40400:40400/udp
      - 8080:8080
    volumes:
      - /root/.aztec/testnet/data/:/data
EOF
  else
    cat > "$tmpfile" <<EOF
services:
  aztec-node:
    container_name: aztec-sequencer
    image: aztecprotocol/aztec:2.0.2
    restart: unless-stopped
    network_mode: host
    environment:
      ETHEREUM_HOSTS: \${ETHEREUM_RPC_URL}
      L1_CONSENSUS_HOST_URLS: \${CONSENSUS_BEACON_URL}
      DATA_DIRECTORY: /data
      VALIDATOR_PRIVATE_KEYS: \${VALIDATOR_PRIVATE_KEYS}
      COINBASE: \${COINBASE}
      P2P_IP: \${P2P_IP}
      LOG_LEVEL: info
    entrypoint: >
      sh -c 'node --no-warnings /usr/src/yarn-project/aztec/dest/bin/index.js start --network testnet --node --archiver --sequencer'
    ports:
      - 40400:40400/tcp
      - 40400:40400/udp
      - 8080:8080
    volumes:
      - /root/.aztec/testnet/data/:/data
EOF
  fi

  if ! cmp -s "$tmpfile" "$file"; then
    mv "$tmpfile" "$file"
    echo "YML_UPDATED_${multivalid:=single}"
  else
    rm "$tmpfile"
  fi
}

fix_env_file_with_key_rename() {
  local env_file="$1"
  local setup_style="$2"

  local env_keys_single=(
    "ETHEREUM_RPC_URL"
    "CONSENSUS_BEACON_URL"
    "VALIDATOR_PRIVATE_KEYS"
    "COINBASE"
    "P2P_IP"
  )
  local env_keys_multi=(
    "ETHEREUM_RPC_URL"
    "CONSENSUS_BEACON_URL"
    "VALIDATOR_PRIVATE_KEYS"
    "PUBLISHER_PRIVATE_KEY"
    "COINBASE"
    "P2P_IP"
  )
  declare -A env_key_keywords=(
    ["ETHEREUM_RPC_URL"]="ethereum"
    ["CONSENSUS_BEACON_URL"]="beacon"
    ["VALIDATOR_PRIVATE_KEYS"]="validator"
    ["PUBLISHER_PRIVATE_KEY"]="publisher"
    ["COINBASE"]="coinbase"
    ["P2P_IP"]="p2p"
  )
  declare -A incorrect_to_correct_key=(
    ["CCONSENSUS_BEACON_URL"]="CONSENSUS_BEACON_URL"
    ["PUBLISHER_PPRIVATE_KEY"]="PUBLISHER_PRIVATE_KEY"
    ["PUBLISHER_PRIVATE_KEYS"]="PUBLISHER_PRIVATE_KEY"
    ["VALIDATOR_PEYS"]="VALIDATOR_PRIVATE_KEYS"
    ["VALIDATOR_PRIVATE_KEY"]="VALIDATOR_PRIVATE_KEYS"
    ["CETHEREUM_RPC_URL"]="ETHEREUM_RPC_URL"
  )

  local required_keys
  if [[ "$setup_style" == "multi" ]]; then
    required_keys=("${env_keys_multi[@]}")
  else
    required_keys=("${env_keys_single[@]}")
  fi

  mapfile -t lines < "$env_file" 2>/dev/null || lines=()

  declare -A current_env=()
  declare -A keys_seen=()
  local fixed_keys=()
  env_fixed_output=()

  for i in "${!lines[@]}"; do
    local line="${lines[i]}"
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

    local key="${line%%=*}"
    local val="${line#*=}"
    key=$(echo -n "$key" | xargs)
    val=$(echo -n "$val" | xargs)

    if [[ -n "${incorrect_to_correct_key[$key]}" ]]; then
      local corr_key="${incorrect_to_correct_key[$key]}"
      fixed_keys+=("$key:$corr_key")
      if [[ -n "$val" ]]; then
        lines[i]="$corr_key=$val"
        current_env[$corr_key]="$val"
        keys_seen["$corr_key"]=1
      else
        local user_val
        prompt_and_clear_line "Value missing for $corr_key (corrected from $key). Enter its value: " user_val "Value for $corr_key captured"
        lines[i]="$corr_key=$user_val"
        current_env[$corr_key]="$user_val"
        keys_seen["$corr_key"]=1
        env_fixed_output+=("  └── Set value: '$corr_key'")
      fi
      continue
    fi

    if [[ " ${required_keys[*]} " == *" $key "* ]]; then
      if [[ -z "$val" ]]; then
        local user_val
        prompt_and_clear_line "Value missing for $key. Enter its value: " user_val "Value for $key captured"
        lines[i]="$key=$user_val"
        current_env[$key]="$user_val"
        env_fixed_output+=("  └── Set value: '$key'")
      else
        current_env[$key]="$val"
      fi
      keys_seen[$key]=1
      continue
    fi
  done

  for req_key in "${required_keys[@]}"; do
    if [[ -z "${keys_seen[$req_key]}" ]]; then
      local keyword="${env_key_keywords[$req_key]}"
      local found_line
      found_line=$(grep -i -m1 "$keyword" "$env_file" 2>/dev/null || true)
      if [[ -n "$found_line" ]]; then
        local found_key="${found_line%%=*}"
        found_key=$(echo -n "$found_key" | xargs)
        local found_val="${found_line#*=}"
        found_val=$(echo -n "$found_val" | xargs)
        if [[ "$found_key" != "$req_key" ]]; then
          fixed_keys+=("$found_key:$req_key")
          if [[ -n "$found_val" ]]; then
            current_env[$req_key]="$found_val"
            keys_seen[$req_key]=1
          else
            local user_val
            prompt_and_clear_line "Value missing for $req_key found as $found_key. Enter its value: " user_val "Value for $req_key captured"
            current_env[$req_key]="$user_val"
            keys_seen[$req_key]=1
            env_fixed_output+=("  └── Set value: '$req_key'")
          fi
        else
          if [[ -z "$found_val" ]]; then
            local user_val
            prompt_and_clear_line "Value missing for $req_key. Enter its value: " user_val "Value for $req_key captured"
            current_env[$req_key]="$user_val"
            keys_seen[$req_key]=1
            env_fixed_output+=("  └── Set value: '$req_key'")
          else
            current_env[$req_key]="$found_val"
            keys_seen[$req_key]=1
          fi
        fi
      else
        local user_val
        prompt_and_clear_line "Key $req_key missing in .env. Enter its value: " user_val "Value for $req_key captured"
        current_env[$req_key]="$user_val"
        keys_seen[$req_key]=1
        env_fixed_output+=("  └── Set value: '$req_key'")
      fi
    fi
  done

  {
    for k in "${required_keys[@]}"; do
      echo "$k=${current_env[$k]}"
    done
  } > "$env_file"

  env_fixed_output_unique=()
  declare -A seen_keys=()
  for pair in "${fixed_keys[@]}"; do
    oldkey="${pair%%:*}"
    newkey="${pair##*:}"
    if [[ -z "${seen_keys[$oldkey]}" ]]; then
      env_fixed_output_unique+=("  └── Fixed '$oldkey' → '$newkey'")
      seen_keys[$oldkey]=1
    fi
  done
  env_fixed_output_unique+=("${env_fixed_output[@]}")

  env_fixed_output=("${env_fixed_output_unique[@]}")
}

check_all_env_keys_status() {
  local env_file="$1"
  local setup_style="$2"
  local errors=0

  local required_keys
  if [[ "$setup_style" == "multi" ]]; then
    required_keys=(\
      "ETHEREUM_RPC_URL" \
      "CONSENSUS_BEACON_URL" \
      "VALIDATOR_PRIVATE_KEYS" \
      "PUBLISHER_PRIVATE_KEY" \
      "COINBASE" \
      "P2P_IP" \
    )
  else
    required_keys=(\
      "ETHEREUM_RPC_URL" \
      "CONSENSUS_BEACON_URL" \
      "VALIDATOR_PRIVATE_KEYS" \
      "COINBASE" \
      "P2P_IP" \
    )
  fi

  missed_keys=()

  for key in "${required_keys[@]}"; do
    if ! grep -q "^$key=" "$env_file" 2>/dev/null; then
      missed_keys+=("$key")
      errors=1
      continue
    fi
    val=$(grep -m1 "^$key=" "$env_file" | cut -d'=' -f2-)
    if [[ -z "$val" ]]; then
      missed_keys+=("$key")
      errors=1
    fi
  done

  if (( errors )); then
    return 1
  fi
  return 0
}

strip_ansi() {
  sed -r "s/\x1B\[[0-9;]*[a-zA-Z]//g"
}

normalize_address() {
  local addr="$1"
  addr=$(echo -e "$addr" | strip_ansi)
  addr=$(echo "$addr" | tr '[:upper:]' '[:lower:]')
  addr="$(echo -e "$addr" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
  echo "$addr"
}

# --- Helper functions for method detection ---

is_cli_process_running() {
  if pgrep -af '[a]ztec start' | grep -v 'docker' > /dev/null; then
    return 0
  else
    return 1
  fi
}

get_labels() {
  local container_id="$1"
  docker inspect --format '{{ range $k, $v := .Config.Labels }}{{ $k }}={{ $v }}
{{ end }}' "$container_id"
}

has_compose_label() {
  local labels="$1"
  if echo "$labels" | grep -q 'com.docker.compose.project'; then
    return 0
  else
    return 1
  fi
}

get_compose_workdir() {
  local labels="$1"
  echo "$labels" | grep 'com.docker.compose.project.working_dir=' | cut -d= -f2- | tr -d '[:space:]'
}
# --------------------------------------------------------------

main() {
  check_prerequisites

  print_header "Aztec Node Addresses"
  container_id=$(docker ps -q --filter name=aztec | head -1 || true)
  workdir="/root/aztec"

  if [[ -z "$container_id" ]]; then
    print_bullet "Node"
    print_subbullet "Status: Not Found" "$cross"
    print_bullet "Validator Addresses"
    print_subbullet "Logs Not Found" "$cross"
    print_bullet "Sequencer Address"
    print_subbullet "Logs Not Found" "$cross"
    print_separator
    return
  fi

  # Detect method
  is_cli_process_running
  cli_running=$?

  labels=$(get_labels "$container_id")
  has_compose_label "$labels"
  compose_label_present=$?

  local method=""

  if [[ $cli_running -eq 0 && $compose_label_present -ne 0 ]]; then
    method="CLI"
  elif [[ $cli_running -ne 0 && $compose_label_present -eq 0 ]]; then
    method="Docker"
    workdir=$(get_compose_workdir "$labels")
    [[ -z "$workdir" ]] && workdir="/root/aztec"
  elif [[ $cli_running -ne 0 && $compose_label_present -ne 0 ]]; then
    method="CLI"
  else
    method="CLI"
  fi

  print_bullet "Node"

  raw_output=$(sudo docker logs "$container_id" 2>&1 | $AWK_BIN '
    BEGIN { validator_found=0; sequencer_found=0 }
    /validator/ && /address/ && $0 !~ /validator Started validator with addresses in current validator committee:/ {
      validator_found=1
      line = $0
      sub(/.*addresses?: /, "", line)
      n = split(line, addrs, ",")
      for(i=1; i<=n; i++) {
        gsub(/^ +| +$/, "", addrs[i])
        print "VALIDATOR:" addrs[i]
      }
    }
    /sequencer.*started.*with address/ {
      if (match($0, /(0x[0-9a-fA-F]{40})/, arr)) {
        sequencer_found=1
        print "SEQUENCER:" arr[1]
      }
    }
    (validator_found && sequencer_found) { exit 0 }
  ')

  sequencer_address=""
  validator_addresses=()
  while IFS= read -r line; do
    if [[ "$line" == VALIDATOR:* ]]; then
      local raw_addr="${line#VALIDATOR:}"
      local addr
      addr=$(normalize_address "$raw_addr")
      validator_addresses+=("$addr")
    elif [[ "$line" == SEQUENCER:* ]]; then
      local raw_seq="${line#SEQUENCER:}"
      sequencer_address=$(normalize_address "$raw_seq")
    fi
  done <<< "$raw_output"

  if [[ ${#validator_addresses[@]} -eq 0 ]]; then
    print_subbullet "Status: Found" "$tick"
    print_subbullet "Addresses: Invalid" "$cross"
    print_subbullet "Method: $method" "$tick"
    if [[ "$method" == "Docker" ]]; then
      print_subbullet "Workdir: $workdir" "$tick"
    fi
    print_bullet "Validator Addresses"
    print_subbullet "Not Found" "$cross"
    print_bullet "Sequencer Address"
    if [[ -z "$sequencer_address" ]]; then
      print_subbullet "Not Found" "$cross"
    else
      print_subbullet "$sequencer_address" "$cross"
    fi
  else
    local address_valid="Invalid"
    for addr in "${validator_addresses[@]}"; do
      if [[ "$addr" == "$sequencer_address" ]]; then
        address_valid="Valid"
        break
      fi
    done
    print_subbullet "Status: Found" "$tick"
    print_subbullet "Addresses: $address_valid" $([[ "$address_valid" == "Valid" ]] && echo "$tick" || echo "$cross")
    print_subbullet "Method: $method" "$tick"
    if [[ "$method" == "Docker" ]]; then
      print_subbullet "Workdir: $workdir" "$tick"
    fi

    print_bullet "Validator Addresses"
    for addr in "${validator_addresses[@]}"; do
      if [[ "$addr" == "$sequencer_address" ]]; then
        print_subbullet "$addr" "$HEAVY_TICK"
      else
        print_subbullet "$addr"
      fi
    done

    print_bullet "Sequencer Address"
    if [[ -z "$sequencer_address" ]]; then
      print_subbullet "Not Found" "$cross"
    else
      print_subbullet "$sequencer_address" $([[ "$address_valid" == "Valid" ]] && echo "$HEAVY_TICK" || echo "$cross")
    fi
  fi

  # If method is CLI
  if [[ "$method" != "Docker" ]]; then
    print_separator
    return 0
  fi

  # Proceed only if method = Docker
  print_header "Aztec Directory Check"
  print_bullet "Directory Path"
  local docker_compose_path="$workdir/docker-compose.yml"
  local env_file="$workdir/.env"
  local print_correction_prompt=0
  local setup_style="single"
  local yaml_valid=0
  local env_check_result=0

  local yml_found=0
  local env_found=0

  if [[ -f "$docker_compose_path" ]]; then
    yml_found=1
    print_subbullet "yml: Found" "$tick"
    setup_style=$(check_yml_validator_and_multi "$docker_compose_path")
    yaml_valid=$?

    if ! check_yml_env_keys "$docker_compose_path" "$setup_style"; then
      yaml_valid=1
      print_correction_prompt=1
    fi
  else
    print_subbullet "yml: Not Found" "$cross"
  fi

  if [[ -f "$env_file" ]]; then
    env_found=1
    print_subbullet "env: Found" "$tick"
    if check_all_env_keys_status "$env_file" "$setup_style"; then
      env_check_result=0
    else
      env_check_result=1
      print_correction_prompt=1
    fi
  else
    print_subbullet "env: Not Found" "$cross"
  fi

  # If both yml and env missing, do not prompt correction
  if (( yml_found == 0 && env_found == 0 )); then
    print_correction_prompt=0
    print_separator
    return 0
  fi

  if (( yaml_valid == 0 )); then
    print_bullet "docker-compose.yml"
    print_status_line "Correct"
    SetupType "$setup_style"
  else
    print_bullet "docker-compose.yml"
    print_status_line "Incorrect"
    SetupType "$setup_style"
    for key in "${missing_keys[@]}"; do
      print_subbullet "$key ✗"
    done
  fi

  print_bullet ".env"
  if (( env_check_result == 0 )); then
    print_status_line "Correct"
  else
    print_status_line "Incorrect"
    local required_keys
    if [[ "$setup_style" == "multi" ]]; then
      required_keys=(\
        "ETHEREUM_RPC_URL" \
        "CONSENSUS_BEACON_URL" \
        "VALIDATOR_PRIVATE_KEYS" \
        "PUBLISHER_PRIVATE_KEY" \
        "COINBASE" \
        "P2P_IP" \
      )
    else
      required_keys=(\
        "ETHEREUM_RPC_URL" \
        "CONSENSUS_BEACON_URL" \
        "VALIDATOR_PRIVATE_KEYS" \
        "COINBASE" \
        "P2P_IP" \
      )
    fi
    for key in "${required_keys[@]}"; do
      local exact_line
      exact_line=$(grep -m1 "^${key}=" "$env_file" || true)
      if [[ -z "$exact_line" ]]; then
        print_subbullet "$key : Misspell $cross"
        continue
      fi
      local val="${exact_line#*=}"
      if [[ -z "$val" ]]; then
        print_subbullet "$key : Empty Value $cross"
        continue
      fi
    done
  fi

  print_separator

  if (( print_correction_prompt == 1 )); then
    printf "● Would you like to Correct the setup ? y/n : "
    read -r fix_choice
    if [[ "$fix_choice" =~ ^[Yy]$ ]]; then
      echo "  └── Yes"
      fix_env_file_with_key_rename "$env_file" "$setup_style"
      yml_fix_msg=$(fix_yml_file "$docker_compose_path" "$setup_style")
      if [[ -n "$yml_fix_msg" ]]; then
        echo "● docker-compose.yml"
        echo "  └── Updated YML → ${yml_fix_msg#YML_UPDATED_}"
      fi
      if [[ ${#env_fixed_output[@]} -gt 0 ]]; then
        echo "● .env"
        for line in "${env_fixed_output[@]}"; do
          echo "$line"
        done
      fi
      print_separator
      echo "Running: docker compose up -d"
      docker compose up -d
      print_separator
      printf "● Setup Fixed: %s\n" "$( [[ $setup_style == multi ]] && echo Multi-Setup || echo Single Setup )"
    else
      echo "  └── No"
      echo "No changes made."
      print_separator
    fi
  fi
}

main "$@"
